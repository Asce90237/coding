#### 二叉搜索树插入操作

注意事项：多个if中若有指针的调整，要特别注意是否可能出现空指针

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) return new TreeNode(val);
        TreeNode pre = null;
        TreeNode cur = root;
        while(cur != null) {
            pre = cur;
            if (cur.val > val) cur = cur.left;
            //这里必须用 else if，不然可能出现空指针，多个if中若有指针的调整
            //要特别注意是否可能出现空指针
            else if (cur.val < val) cur = cur.right;
        }
        if (pre.val > val) {
            pre.left = new TreeNode(val);
        } else pre.right = new TreeNode(val);
        return root;
    }
}
```

### 二叉树的最近公共祖先

情况一：左右节点都不为空，即pq出现在其左右子树上

情况二：q在p的左右子树上，那么此时p即为最近公共祖先

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //这里包含着一个节点可以是它自己的祖先，也就是遇到p或q直接返回，不会再继续向下递归
        if (root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if (left != null && right != null) return root;
        else if (left != null && right == null) return left;
        else if (left == null && right != null) return right;
        else return null;
    }
}
```

### 二叉搜索树的最近公共祖先

问题：为什么从上往下遍历出现的第一个在区间内的节点就是最近公共节点

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return root;
        if (root.val > p.val && root.val > q.val) {
            TreeNode left = lowestCommonAncestor(root.left,p,q);
            if (left != null) return left;
        }
        if (root.val < p.val && root.val < q.val) {
            TreeNode right = lowestCommonAncestor(root.right,p,q);
            if (right != null) return right;
        }
        //为什么遇到的第一个再区间内的节点就是最近公共祖先？
        //answer：若在区间内，则意为着p或q在当前节点的左右子树内
        //若此时往左或往右，都会失去，p或q其中的一个节点
        return root;
    }
}
```