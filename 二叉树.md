#### 二叉树结构定义

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    public TreeNode() {};
    public TreeNode(int val) {
        this.val = val;
    }
    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

#### 二叉树遍历

```java
// 递归 (这里是前序遍历，中序和后序遍历只需调整中间节点处理逻辑的位置就行)
public void traversal(TreeNode root) {
    if (root == null) return;
    // 中 (这一行是中间节点的处理逻辑)
    traversal(root.left); // 左
    traversal(root.right); // 右
}
// 迭代 (这里给出的前序遍历，用栈模拟递归)
Stack<TreeNode> st = new Stack<>();
st.push(root);
while(!st.isEmpty()) {
    TreeNode cur = st.pop();
    // 中间节点处理逻辑
    if (cur.right != null) st.push(cur.right); // 右 (先右的原因是利用栈先入后出的特性)
    if (cur.left != null) st.push(cur.left); // 左
}
// 中序遍历
Stack<TreeNode> st = new Stack<>();
// 注意这里是 ||，因为第一个节点还未放入栈中，当第一个节点放入栈中后，一边向左遍历，直到遍历为空为止，遍历的过程中用栈保存遍历过的节点，以便后续的处理
while(!st.isEmpty() || root != null) {
    if (root != null) {
        st.push(root);
        root = root.left; // 左
    } else {
        root = st.pop();
        // 中间节点处理逻辑
        root = root.right; // 右
    }
}
// 后序遍历利用前序遍历调换左右节点加入的顺序，得到中-右-左，最后反转数组得到左-右-中，即为后序遍历的顺序
// 层序遍历
Queue<TreeNode> que = new LinkedList<>();
que.offer(root);
while(!que.isEmpty()) {
    int size = que.size(); // 这里需要记录当前层节点的数量，因为后序处理过程会再次添加节点
    while(size-- > 0) {
        TreeNode cur = que.poll();
        // 中间节点处理逻辑
        if (cur.left != null) que.offer(cur.left);
        if (cur.right != null) que.offer(cur.right);
    }
}
```

#### 翻转二叉树

思路：中间节点处理逻辑为交换左右节点

递归实现注意事项：前序遍历和后序遍历都可以正常实现，就是遍历每一个节点将其左右节点交换一下就行，但是中序遍历会导致，前面要处理的右节点，在替换后已经到了树的左边，所以接下来还要再次替换左节点才能真正的实现翻转。

迭代实现使用层序遍历，只要正常遍历每一个节点就可以了

#### 对称二叉树

思路：同时遍历左右左右子树，比较最里层的节点和最外层的节点

递归解法和迭代解法类似，要注意的是迭代只需要保证要比较的两个节点紧紧的挨在一起，这样才方便后序的比对，使用队列可以很好的做到这点，当然栈也可以实现，因为我们只需要保证比较的节点顺序就好了。

#### 二叉搜索树插入操作

注意事项：多个if中若有指针的调整，要特别注意是否可能出现空指针

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) return new TreeNode(val);
        TreeNode pre = null;
        TreeNode cur = root;
        while(cur != null) {
            pre = cur;
            if (cur.val > val) cur = cur.left;
            //这里必须用 else if，不然可能出现空指针，多个if中若有指针的调整
            //要特别注意是否可能出现空指针
            else if (cur.val < val) cur = cur.right;
        }
        if (pre.val > val) {
            pre.left = new TreeNode(val);
        } else pre.right = new TreeNode(val);
        return root;
    }
}
```

### 二叉树的最近公共祖先

情况一：左右节点都不为空，即pq出现在其左右子树上

情况二：q在p的左右子树上，那么此时p即为最近公共祖先

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //这里包含着一个节点可以是它自己的祖先，也就是遇到p或q直接返回，不会再继续向下递归
        if (root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if (left != null && right != null) return root;
        else if (left != null && right == null) return left;
        else if (left == null && right != null) return right;
        else return null;
    }
}
```

### 二叉搜索树的最近公共祖先

问题：为什么从上往下遍历出现的第一个在区间内的节点就是最近公共节点

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return root;
        if (root.val > p.val && root.val > q.val) {
            TreeNode left = lowestCommonAncestor(root.left,p,q);
            if (left != null) return left;
        }
        if (root.val < p.val && root.val < q.val) {
            TreeNode right = lowestCommonAncestor(root.right,p,q);
            if (right != null) return right;
        }
        //为什么遇到的第一个再区间内的节点就是最近公共祖先？
        //answer：若在区间内，则意为着p或q在当前节点的左右子树内
        //若此时往左或往右，都会失去，p或q其中的一个节点
        return root;
    }
}
```