#### 二叉树结构定义

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    public TreeNode() {};
    public TreeNode(int val) {
        this.val = val;
    }
    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

#### 二叉树遍历

```java
// 递归 (这里是前序遍历，中序和后序遍历只需调整中间节点处理逻辑的位置就行)
public void traversal(TreeNode root) {
    if (root == null) return;
    // 中 (这一行是中间节点的处理逻辑)
    traversal(root.left); // 左
    traversal(root.right); // 右
}
// 迭代 (这里给出的前序遍历，用栈模拟递归)
Stack<TreeNode> st = new Stack<>();
st.push(root);
while(!st.isEmpty()) {
    TreeNode cur = st.pop();
    // 中间节点处理逻辑
    if (cur.right != null) st.push(cur.right); // 右 (先右的原因是利用栈先入后出的特性)
    if (cur.left != null) st.push(cur.left); // 左
}
// 中序遍历
Stack<TreeNode> st = new Stack<>();
// 注意这里是 ||，因为第一个节点还未放入栈中，当第一个节点放入栈中后，一边向左遍历，直到遍历为空为止，遍历的过程中用栈保存遍历过的节点，以便后续的处理
while(!st.isEmpty() || root != null) {
    if (root != null) {
        st.push(root);
        root = root.left; // 左
    } else {
        root = st.pop();
        // 中间节点处理逻辑
        root = root.right; // 右
    }
}
// 后序遍历利用前序遍历调换左右节点加入的顺序，得到中-右-左，最后反转数组得到左-右-中，即为后序遍历的顺序
// 层序遍历
Queue<TreeNode> que = new LinkedList<>();
que.offer(root);
while(!que.isEmpty()) {
    int size = que.size(); // 这里需要记录当前层节点的数量，因为后序处理过程会再次添加节点
    while(size-- > 0) {
        TreeNode cur = que.poll();
        // 中间节点处理逻辑
        if (cur.left != null) que.offer(cur.left);
        if (cur.right != null) que.offer(cur.right);
    }
}
```

#### 翻转二叉树

思路：中间节点处理逻辑为交换左右节点

递归实现注意事项：前序遍历和后序遍历都可以正常实现，就是遍历每一个节点将其左右节点交换一下就行，但是中序遍历会导致，前面要处理的右节点，在替换后已经到了树的左边，所以接下来还要再次替换左节点才能真正的实现翻转。

迭代实现使用层序遍历，只要正常遍历每一个节点就可以了

#### 对称二叉树

思路：同时遍历左右左右子树，比较最里层的节点和最外层的节点

递归解法和迭代解法类似，要注意的是迭代只需要保证要比较的两个节点紧紧的挨在一起，这样才方便后序的比对，使用队列可以很好的做到这点，当然栈也可以实现，因为我们只需要保证比较的节点顺序就好了。

#### 二叉树的最大深度

思路：深度和高度不一样，深度是指从根节点到某一节点的路径长，一般用前序遍历求得；高度是指从某一节点到叶子节点的路径长，一般用后序遍历求得，但本题最大深度就是从根节点到叶子节点的高度，所以用后序遍历来求较为方便，只需要返回每层左右节点高度的最大值加上当前层即为所求。

迭代使用层序遍历，易理解，不过递归更简便。

#### 二叉树的最小深度

跟求最大深度的思路差不多，但是要注意的是，若有某个节点的左子树为空，此时应该返回其右子树的最小深度，不能直接返回左右子树的最小深度的较小值。

#### 完全二叉树的节点个数

思路：利用满二叉树节点数的特性，高度为n的满二叉树的节点个数为2 ^ n  - 1，同时遍历当前节点的左右子树，若其左右高度相等，则直接返回 公式所求的值，若不相等，则递归求左右子树的个数，如果是求普通二叉树的节点个数，则可以直接递归求左右子树个数，但若是求完全二叉树的节点个数，我们则要利用好其特性。

#### 平衡二叉树

思路：递归返回值为以遍历的节点为根节点的高度，若为-1，则说明已经不是平衡二叉树了，直接返回，因为平衡二叉树的定义为左右子树的高度差不能大于1，要求高度，所以，需要后序遍历，若左右节点递归回来的结果有-1，则直接返回-1，若不为-1，则根据高度差是否大于1来决定是否返回-1。

#### 二叉树的所有路径

思路：递归，回溯来遍历所有所有的情况，终止条件是，当遇到叶子节点时，若此时的计数器为0，则加入结果集，若不为0，直接返回，准备回溯操作，回溯就是将当前遍历的集合删除掉刚才插入的那个元素。

本题也可以使用栈来模拟递归从而实现迭代法，这里只需要定义一个泛型为Object类型的栈，将当前路径和随当前节点一起放入栈中，后序的判断条件和递归一致，但是要注意，因为是Object泛型，所以后面取元素时需要强转取出来的元素。

#### 左叶子之和

思路：这题递归很好解决，首先因为是叶子，所以递归终止条件就必须有其左右节点为空时才处理，其次是左右子，这里可以直接使用一个全局标记位，在后序要进行左子树的递归前就将标记位置为true，同样的，右子树前必须置为false，递归终止条件也必须含有当标记位为真时才做累加操作。

#### 二叉搜索树插入操作

注意事项：多个if中若有指针的调整，要特别注意是否可能出现空指针

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) return new TreeNode(val);
        TreeNode pre = null;
        TreeNode cur = root;
        while(cur != null) {
            pre = cur;
            if (cur.val > val) cur = cur.left;
            //这里必须用 else if，不然可能出现空指针，多个if中若有指针的调整
            //要特别注意是否可能出现空指针
            else if (cur.val < val) cur = cur.right;
        }
        if (pre.val > val) {
            pre.left = new TreeNode(val);
        } else pre.right = new TreeNode(val);
        return root;
    }
}
```

### 二叉树的最近公共祖先

情况一：左右节点都不为空，即pq出现在其左右子树上

情况二：q在p的左右子树上，那么此时p即为最近公共祖先

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //这里包含着一个节点可以是它自己的祖先，也就是遇到p或q直接返回，不会再继续向下递归
        if (root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if (left != null && right != null) return root;
        else if (left != null && right == null) return left;
        else if (left == null && right != null) return right;
        else return null;
    }
}
```

### 二叉搜索树的最近公共祖先

问题：为什么从上往下遍历出现的第一个在区间内的节点就是最近公共节点

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return root;
        if (root.val > p.val && root.val > q.val) {
            TreeNode left = lowestCommonAncestor(root.left,p,q);
            if (left != null) return left;
        }
        if (root.val < p.val && root.val < q.val) {
            TreeNode right = lowestCommonAncestor(root.right,p,q);
            if (right != null) return right;
        }
        //为什么遇到的第一个再区间内的节点就是最近公共祖先？
        //answer：若在区间内，则意为着p或q在当前节点的左右子树内
        //若此时往左或往右，都会失去，p或q其中的一个节点
        return root;
    }
}
```