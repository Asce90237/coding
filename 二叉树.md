#### 二叉树结构定义

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    public TreeNode() {};
    public TreeNode(int val) {
        this.val = val;
    }
    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

#### 二叉树的种类

**满二叉树**：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

![img](./%E4%BA%8C%E5%8F%89%E6%A0%91/20200806185805576.png)

这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。**注意利用这个特性去求完全二叉树的节点个数**

**完全二叉树**：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。通俗一点来讲就是必须每个节点必须按照满二叉树的节点编号来编号。

![img](./%E4%BA%8C%E5%8F%89%E6%A0%91/20200920221638903.png)

**优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。**

**二叉搜索树**是一个有序树，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树

![img](./%E4%BA%8C%E5%8F%89%E6%A0%91/20200806190304693.png)

**平衡二叉搜索树**又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

![img](./%E4%BA%8C%E5%8F%89%E6%A0%91/20200806190511967.png)

#### 二叉树的存储方式

链式存储：

![img](./%E4%BA%8C%E5%8F%89%E6%A0%91/2020092019554618.png)

顺序存储：

![img](./%E4%BA%8C%E5%8F%89%E6%A0%91/20200920200429452.png)

**如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。**

#### 二叉树遍历

二叉树主要有两种遍历方式：

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

**这两种遍历是图论中最基本的两种遍历方式**，后面在介绍图论的时候 还会介绍到。

那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：

- 深度优先遍历
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历
  - 层次遍历（迭代法）

![img](./%E4%BA%8C%E5%8F%89%E6%A0%91/20200806191109896.png)

```java
// 递归 (这里是前序遍历，中序和后序遍历只需调整中间节点处理逻辑的位置就行)
public void traversal(TreeNode root) {
    if (root == null) return;
    // 中 (这一行是中间节点的处理逻辑)
    traversal(root.left); // 左
    traversal(root.right); // 右
}
// 迭代 (这里给出的前序遍历，用栈模拟递归)
Stack<TreeNode> st = new Stack<>();
st.push(root);
while(!st.isEmpty()) {
    TreeNode cur = st.pop();
    // 中间节点处理逻辑
    if (cur.right != null) st.push(cur.right); // 右 (先右的原因是利用栈先入后出的特性)
    if (cur.left != null) st.push(cur.left); // 左
}
// 中序遍历
Stack<TreeNode> st = new Stack<>();
// 注意这里是 ||，因为第一个节点还未放入栈中，当第一个节点放入栈中后，一边向左遍历，直到遍历为空为止，遍历的过程中用栈保存遍历过的节点，以便后续的处理
while(!st.isEmpty() || root != null) {
    if (root != null) {
        st.push(root);
        root = root.left; // 左
    } else {
        root = st.pop();
        // 中间节点处理逻辑
        root = root.right; // 右
    }
}
// 后序遍历利用前序遍历调换左右节点加入的顺序，得到中-右-左，最后反转数组得到左-右-中，即为后序遍历的顺序
// 层序遍历
Queue<TreeNode> que = new LinkedList<>();
que.offer(root);
while(!que.isEmpty()) {
    int size = que.size(); // 这里需要记录当前层节点的数量，因为后序处理过程会再次添加节点
    while(size-- > 0) {
        TreeNode cur = que.poll();
        // 中间节点处理逻辑
        if (cur.left != null) que.offer(cur.left);
        if (cur.right != null) que.offer(cur.right);
    }
}
```

#### 翻转二叉树

![226.翻转二叉树](./%E4%BA%8C%E5%8F%89%E6%A0%91/20210203192644329.png)

思路：想要翻转它，其实就把每一个节点的左右孩子交换一下就可以了。关键在于遍历顺序，前中后序应该选哪一种遍历顺序？遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。**注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果，这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次**！如果非要使用中序遍历，则在中间节点处理后，需要再次处理左边的节点，因为先前右边的节点已经被交换至左边。

层序遍历也是如此，也可以解决本题，**只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！**

#### 对称二叉树

![101. 对称二叉树](./%E4%BA%8C%E5%8F%89%E6%A0%91/20210203144607387.png)

思路：确定对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

如何比较：比较的是两个子树的里侧和外侧的元素是否相等。

![image-20230803111024586](./%E4%BA%8C%E5%8F%89%E6%A0%91/image-20230803111024586.png)

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

**正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**

递归解法和迭代解法类似，要注意的是迭代只需要保证要比较的两个节点紧紧的挨在一起，这样才方便后序的比对，使用队列可以很好的做到这点，当然栈也可以实现，因为我们只需要保证比较的节点顺序就好了。

#### 二叉树的最大深度

递归法：可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）

**而根节点的高度就是二叉树的最大深度**，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。

迭代法使用层序遍历，易理解，二叉树的层数就是他的最大深度，不过递归更简便。

#### 二叉树的最小深度

跟求最大深度的思路差不多，但是要注意的是，若有某个节点的左子树为空，此时应该返回其右子树的最小深度，不能直接返回左右子树的最小深度的较小值，因为**最小深度是从根节点到最近叶子节点的最短路径上的节点数量**，是叶子节点，于是不能像求最大深度那样直接返回递归回来的结果的最小值。

#### 完全二叉树的节点个数

![img](./%E4%BA%8C%E5%8F%89%E6%A0%91/20200920221638903-20230310123444151.png)

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

![image-20230804102906804](./%E4%BA%8C%E5%8F%89%E6%A0%91/image-20230804102906804.png)

本题关键，如何判断一颗二叉树是否是满二叉树？

在**完全二叉树**中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。注意必须是完全二叉树才可以这样求，否则不行。

![image-20230804103140829](./%E4%BA%8C%E5%8F%89%E6%A0%91/image-20230804103140829.png)

#### 平衡二叉树

思路：求高度使用后序遍历，递归返回值为以遍历的节点为根节点的高度，若为-1，则说明已经不是平衡二叉树了，直接返回，因为平衡二叉树的定义为左右子树的高度差不能大于1，要求高度，所以，需要后序遍历，若左右节点递归回来的结果有-1，则直接返回-1，若不为-1，则根据高度差是否大于1来决定是否返回-1。

#### 二叉树的所有路径

思路：递归，回溯来遍历所有所有的情况，终止条件是，当遇到叶子节点时，若此时的计数器为0，则加入结果集，若不为0，直接返回，准备回溯操作，回溯就是将当前遍历的集合删除掉刚才插入的那个元素。

本题也可以使用栈来模拟递归从而实现迭代法，这里只需要定义一个泛型为Object类型的栈，将当前路径和随当前节点一起放入栈中，后序的判断条件和递归一致，但是要注意，因为是Object泛型，所以后面取元素时需要强转取出来的元素。

#### 左叶子之和

思路：这题递归很好解决，首先因为是叶子，所以递归终止条件就必须有其左右节点为空时才处理，其次是左右子，这里可以直接使用一个全局标记位，在后序要进行左子树的递归前就将标记位置为true，同样的，右子树前必须置为false，递归终止条件也必须含有当标记位为真时才做累加操作。

#### 找树左下角的值

思路：递归，因为需要找到最底层且靠左边的节点，所以需使用前序遍历，定义一个全局的maxDepth，递归参数中还需要包含当前遍历节点的深度，因为是前序遍历，中左右，所以如果遇到深度大于maxDepth时，则更新它，并将遇到的第一个值，记录下它，因为它就是先处理的第一个靠左的节点，并且此时更新了maxDepth，所以同层的值并不会更新最后的结果

迭代法更好理解一点，直接就是层序遍历时遇到每一层第一个节点，就将该值记录下来，直到遍历了整颗树后，最后的结果就是最底层且最靠左的节点

#### 路径总和

思路：和前面记录二叉树的所有路径方法类似，只不过本题不需要遍历一整颗树，如果遇到符合题意的路径，则直接返回true，不需要继续遍历了

```java
//注意如果是遍历整棵树，递归逻辑代码大致如下
traversal(root.left, cnt - root.left.val);
traversal(root.right, cnt - root.right.val);
//如果是找出其中一条路径
if (traversal(root.left, cnt - root.left.val)) return true;
if (traversal(root.right, cnt - root.right.val)) return true;
```

#### 从中序与后序遍历序列构造二叉树

思路：以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。

递归步骤：

- 第一步：如果数组大小为零的话，说明是空节点了。
- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
- 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
- 第五步：切割后序数组，切成后序左数组和后序右数组
- 第六步：递归处理左区间和右区间

#### 最大二叉树

问题：给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

- 二叉树的根是数组中的最大元素。
- 左子树是通过数组中最大值左边部分构造出的最大二叉树。
- 右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。

思路：跟上面构造二叉树的思路差不多，甚至比他们还简单一点，同样的我们不需要创建多余的数组，递归参数直接传入起始和终止的下标就可，但是要注意确定你是左闭右开还是左闭右闭，那种都可以，但是要确保一直保持这种状态的。

#### 合并二叉树

![617.合并二叉树](./%E4%BA%8C%E5%8F%89%E6%A0%91/20230310000854.png)

思路：递归前中后序遍历都可以，只要保证每层合并后的结果返回给上层节点就可，可以直接在root1的基础上修改，也就是添加操作都在前一颗树上操作，迭代法的话，要注意当两个节点都不为空在将他们都加入队列中，直接进行合并操作，然后只需要判断root1的节点左右节点为空即可，因为我们选择保留root1的树结构，在其基础上进行合并操作，所以不需要判断root2左右节点为空的情况。

#### 二叉树的搜索

问题：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

思路：递归法，终止条件当遍历的节点为空时直接返回，然后根据当前节点的值和给定值的大小确定要向左遍历还是向右遍历，若刚好找到则直接返回

迭代法：虽然一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。

对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法。

对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。

而**对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。**

例如要搜索元素为3的节点，**我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。**中间节点如果大于3就向左走，如果小于3就向右走

![二叉搜索树](./%E4%BA%8C%E5%8F%89%E6%A0%91/20200812190213280.png)

#### 验证二叉树

问题：给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

思路：要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。有了这个特性，**验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了**，但是本题有两个陷阱：

- **不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了**，**我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点**。

- 样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。此时可以初始化比较元素为longlong的最小值。

  但是如果样例中根节点的val 可能是longlong的最小值，上面那种办法就不好使了。

所以这里要用到一个指针，指向遍历的前一个节点，只要我们进行中序遍历，那么我们只需要判断这个指针的值和当前节点的值的大小即可。

这样就可以避免初始化的最小值，直接拿靠左边的值来进行比较。

#### 二叉搜索树插入操作

注意事项：多个if中若有指针的调整，要特别注意是否可能出现空指针

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) return new TreeNode(val);
        TreeNode pre = null;
        TreeNode cur = root;
        while(cur != null) {
            pre = cur;
            if (cur.val > val) cur = cur.left;
            //这里必须用 else if，不然可能出现空指针，多个if中若有指针的调整
            //要特别注意是否可能出现空指针
            else if (cur.val < val) cur = cur.right;
        }
        if (pre.val > val) {
            pre.left = new TreeNode(val);
        } else pre.right = new TreeNode(val);
        return root;
    }
}
```

### 二叉树的最近公共祖先

情况一：左右节点都不为空，即pq出现在其左右子树上

情况二：q在p的左右子树上，那么此时p即为最近公共祖先

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //这里包含着一个节点可以是它自己的祖先，也就是遇到p或q直接返回，不会再继续向下递归
        if (root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if (left != null && right != null) return root;
        else if (left != null && right == null) return left;
        else if (left == null && right != null) return right;
        else return null;
    }
}
```

### 二叉搜索树的最近公共祖先

问题：为什么从上往下遍历出现的第一个在区间内的节点就是最近公共节点

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return root;
        if (root.val > p.val && root.val > q.val) {
            TreeNode left = lowestCommonAncestor(root.left,p,q);
            if (left != null) return left;
        }
        if (root.val < p.val && root.val < q.val) {
            TreeNode right = lowestCommonAncestor(root.right,p,q);
            if (right != null) return right;
        }
        //为什么遇到的第一个再区间内的节点就是最近公共祖先？
        //answer：若在区间内，则意为着p或q在当前节点的左右子树内
        //若此时往左或往右，都会失去，p或q其中的一个节点
        return root;
    }
}
```