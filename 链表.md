#### 移除链表元素

问题：删除链表中等于给定值 val 的所有节点。

思路：这种关于删除的问题，很容易涉及到头节点的操作，因为如果要删除的元素是头节点，那么它的删除方法就是直接移除头节点，而删除其他的节点的方法则是找到其前面一个节点，这就造成了不一致的情况，需要分情况讨论，所以这里我们用到虚拟头节点，这样所有节点的删除逻辑就都一样，都是找到要删除节点的前一个节点就可以删除了，最后我们要返回的是删除后的链表新的头节点，这个就是虚拟头节点的下一个节点。

#### 设计链表

思路：同样也是利用虚拟头节点，假如要添加节点到指定位置，那么就要找到该节点的前一个位置，也就是index - 1的位置，所以可以直接从虚拟头节点循环index次，正是因为有了虚拟头节点的存在，循环index次就相当于将指针移到下标index - 1的位置；若是要删除节点，同样的思路，也是从虚拟头节点开始循环，而要获得下标为index的节点的值，则要从真正的头节点出发，也就是虚拟头节点的下一个节点开始。

#### 翻转链表

问题：反转一个单链表。

思路：定义一个pre节点（初始为null）和一个cur节点，每次都先记录cur的下一个节点的指针，因为接下来要操作cur的指针了，将cur的指针指向pre的位置，然后pre指向cur，最后cur再次前移到刚才记录的下一个节点的位置，重复该操作直到cur指向了null，这时pre所在的位置就是翻转后的头节点，直接返回即可。

本题递归和迭代的思路一样，只是写法不同而已。

#### 两两交换链表中的节点

思路：递归思路很明确，每层递归记录新的头节点，以及下一层要开始的头节点，然后按题意连接各节点，画图的话就会很简单。

#### 删除链表的倒数第N个节点

思路：快慢指针，原理就是，若快指针初始时比慢指针先走n步，那么若这时两个指针同时出发，直到快指针到链表结尾，此时慢指针因为初始时比快指针少走n步，距离就差了n步，所以此时慢指针所在的位置就是倒数第n个节点，而一般删除指定节点，都是要找到其前一个节点，所以这里只需要找到倒数第n + 1个节点就好了，那么就是快指针先走n + 1步。

#### 链表相交

思路：一句话：我走过你来时的路，回头看你也走过我来时的路。

#### 环形链表Ⅱ

问题：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。**说明**：不允许修改给定的链表。

思路：

##### 判断链表是否有环

可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。原理：首先第一点：**fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。其实相对于slow来说，fast是一个节点一个节点的靠近slow的**，所以fast一定可以和slow重合。

##### 找到环的入口

假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。

![image-20230826105622201](./%E9%93%BE%E8%A1%A8/image-20230826105622201.png)

那么相遇时： slow指针走过的节点数为: `x + y`， fast指针走过的节点数：`x + y + n (y + z)`，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。

因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：

```
(x + y) * 2 = x + y + n (y + z)
```

两边消掉一个（x+y）: `x + y = n (y + z)`

因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。

所以要求x ，将x单独放在左面：`x = n (y + z) - y` ,

再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：`x = (n - 1) (y + z) + z` 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。

先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。

当 n为1的时候，公式就化解为 `x = z`，

这就意味着，**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。

让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。

![image-20230826105739183](./%E9%93%BE%E8%A1%A8/image-20230826105739183.png)

即使 n大于1，就是fast指针在环形转n圈之后才遇到 slow指针。

其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {// 有环
                ListNode index1 = fast;
                ListNode index2 = head;
                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口
                while (index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
        return null;
    }
}
```

